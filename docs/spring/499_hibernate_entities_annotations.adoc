=== Объектно-реляционное преобразование с помощью аннотаций Hibernate

==== Простые преобразования

*_See_* _p490_start_with_hibernate/entity/..._

Рассмотрим преобразования простых атрибутов класса (_Singer_):

- Атрибут _birthDate_ снабжается аннотацией *_@Temporal(TemporalТуре.DATE)_*. Это означает, что тиn Java (_java.util.Date_) желательно преобразовать в тиn данных SQL (_java.sql.Date_). Это дает возможность получить в приложении доступ к свойству birthDate из объекта Singer, используя, как обычно, тип данных java.util.Date.
- Атрибут id снабжается аннотацией *_@Id_*. Это означает, что он является первичным ключом объекта. В Hibernate он будет однозначным идентификатором для сущности. Кроме того, аннотация *_@GeneratedValue(strategy = GenerationType.IDENTITY)_* сообщает Hibernate, каким образом было сгенерировано значение идентификатора id. Значение _IDENТITY_ атрибута strategy в этой аннотации означает, что идентификатор сгенерирован СУРБД во время вставки данных.
- Атрибут version снабжен аннотацией *_@Version_*. Тем самым Hibernate сообщается, что в данном случае требуется применить механизм оптимистичной блокировки, а для его управления - атрибут _version_. +
Всякий раз, когда библиотека Hibernate обновляет запись, она *_сравнивает версию_* экземпляра сущности с *_версией записи в базе данных_*. Если версии совпадают, значит, данные раньше не обновлялись, и Hibernate обновит данные и увеличит значение _version_. Но если версии отличаются, то это означает, что кто-то уже обновил запись, и тогда Hibernate сгенерирует исключение типа _StaleObjectStateException_, которое Spring преобразует в исключение типа *_HibernateOptimisticLockingFailureException_*. +
По сути, спорный пункт (транзакционность и изолированность данных обеспечивается в первую очередь самой базой данных, а не JPA), можно почитать КОММЕНТЫ к link:https://habr.com/ru/post/434836/#comment_19571612[статье] на хабре.

==== Связи "one-to-many"

Библиотека Hibernate обладает способностью моделировать самые разные виды связей. Наиболее распространенными являются связи *_one-to-many_* и *_many-to-many_* (существует еще _one-to-one_). У каждого певца может быть 0 или больше альбомов, из чего получается связь _one-to-many_ между сущностями типа Singer и Album:

*_See_* _p490_start_with_hibernate/entity/Singer.java_

Метод получения значения из свойства albums снабжен аннотацией *_@OneToMany_*, которая указывает на связь с классом Album. Этой аннотации передается несколько атрибутов:

1. В атрибуте *_mappedBy_* задается свойство _singer_ из класса Album, *_обеспечивающее связь_* (по определению внешнего ключа из таблицы _FK_ALBUM_SINGER_).
2. Атрибут *_cascade_* означает, что операция обновления должна распространяться "каскадом" на порожденные записи.
3. Атрибут *_orphanRemoval_* указывает, что удалении записи в таблице _singer_, соответствующие ей записи из таблицы _album_ также удаляются.

*_See_* _p490_start_with_hibernate/entity/Album.java_

В коде класса _Album_ поле singer снабжено аннотацией *_@ManyToOne_*, где задается другая сторона связи с классом Singer. В этом коде была также указана аннотация *_@JoinColumn_* для столбца с именем внешнего ключа.

==== Связи "many-to-many"

Каждый певец может играть на нескольких музыкальных инструментах или ни на одном из них, а каждый инструмент может быть связан с несколькими певцами или же ни с одним из них, что, по существу, означает связь "*_many-to-many_*". Для таких связей требуется промежуточная таблица, через которую осуществляется соединение. В данном случае это таблица singer_instrument:

*_See_* _p490_start_with_hibernate/entity/Singer.java_

Для реализации такой связи над полем _instruments_ класса _Singer_ требуются две аннотации:

1. *_@ManyToMany(cascade = { CascadeType.ALL })_* для указания many-to-many связи и настройке каскадности (при действиях над *_id_* entity Singer).
2. Совместно с ней используется аннотация *_@JoinTable_* для указания промежуточной таблицы для соединения, которую должна искать библиотека Hibernate.
- Атрибут *_name_* задает имя промежуточной таблицы.
- В атрибуте *_joinColumns_* определяется столбец внешнего ключа для текущей entity (Singer), а в атрибуте *_inverseJoinColumns_* указывается столбец с внешним ключом для таблицы Instrument на другой стороне устанавливаемой связи.

*_See_* _p490_start_with_hibernate/entity/Instrument.java_

В класса Instrument дополнительно реализована другая сторона рассматриваемого здесь отношения (значения аттрибутов joinColumns и inverseJoinColumns поменялись местами).