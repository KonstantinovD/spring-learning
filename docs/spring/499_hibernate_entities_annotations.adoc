=== Объектно-реляционное преобразование с помощью аннотаций Hibernate

- Простые преобразования
- Связи "one-to-many"
- Связи "many-to-many"
- CascadeTypes


==== Простые преобразования

*_See_* _p490_start_with_hibernate/entity/..._

Рассмотрим преобразования простых атрибутов класса (_Singer_):

- Атрибут _birthDate_ снабжается аннотацией *_@Temporal(TemporalТуре.DATE)_*. Это означает, что тиn Java (_java.util.Date_) желательно преобразовать в тиn данных SQL (_java.sql.Date_). Это дает возможность получить в приложении доступ к свойству birthDate из объекта Singer, используя, как обычно, тип данных java.util.Date.
- Атрибут id снабжается аннотацией *_@Id_*. Это означает, что он является первичным ключом объекта. В Hibernate он будет однозначным идентификатором для сущности. Кроме того, аннотация *_@GeneratedValue(strategy = GenerationType.IDENTITY)_* сообщает Hibernate, каким образом было сгенерировано значение идентификатора id. Значение _IDENТITY_ атрибута strategy в этой аннотации означает, что идентификатор сгенерирован СУРБД во время вставки данных.
- Атрибут version снабжен аннотацией *_@Version_*. Тем самым Hibernate сообщается, что в данном случае требуется применить механизм оптимистичной блокировки, а для его управления - атрибут _version_. +
Всякий раз, когда библиотека Hibernate обновляет запись, она *_сравнивает версию_* экземпляра сущности с *_версией записи в базе данных_*. Если версии совпадают, значит, данные раньше не обновлялись, и Hibernate обновит данные и увеличит значение _version_. Но если версии отличаются, то это означает, что кто-то уже обновил запись, и тогда Hibernate сгенерирует исключение типа _StaleObjectStateException_, которое Spring преобразует в исключение типа *_HibernateOptimisticLockingFailureException_*. +
По сути, спорный пункт (транзакционность и изолированность данных обеспечивается в первую очередь самой базой данных, а не JPA), можно почитать КОММЕНТЫ к link:https://habr.com/ru/post/434836/#comment_19571612[статье] на хабре.

А также можно добавить и другие полезные анноташки:

- *_@Enumerated_*(EnumType.STRING) or EnumType.ORDINAL
- *_@Type_*(type = SomeJsonType.NAME) +
private SomeDataType data;
- *_@Transient_* спользуется чтобы указать, что поле не должно быть persisted и не должно быть сохранено в БД.

==== Связи "one-to-many"

Библиотека Hibernate обладает способностью моделировать самые разные виды связей. Наиболее распространенными являются связи *_one-to-many_* и *_many-to-many_* (существует еще _one-to-one_). У каждого певца может быть 0 или больше альбомов, из чего получается связь _one-to-many_ между сущностями типа Singer и Album:

*_See_* _p490_start_with_hibernate/entity/Singer.java_

Метод получения значения из свойства albums снабжен аннотацией *_@OneToMany_*, которая указывает на связь с классом Album. Этой аннотации передается несколько атрибутов:

1. В атрибуте *_mappedBy_* задается свойство _singer_ из класса Album, *_обеспечивающее связь_* (по определению внешнего ключа из таблицы _FK_ALBUM_SINGER_).
2. Атрибут *_cascade_* означает, что операция обновления должна распространяться "каскадом" на порожденные записи. *_See_* link:https://www.baeldung.com/jpa-cascade-types[jpa-cascade-types], link:https://sysout.ru/tipy-cascade-primer-na-hibernate-i-spring-boot/[rus tutorial]
3. Атрибут *_orphanRemoval_* указывает, что удалении записи из списка альбомов объекта типа _singer_, соответствующая запись из таблицы _album_ будет удалена. В противном случае в FK записи _album_ проставится _NULL_. *_ВАЖНО!_* За удаление всех _album_ при удалении соответсвующего _singer_ отвечает *_CascadeType.REMOVE_*.

*_See_* _p490_start_with_hibernate/entity/Album.java_

В коде класса _Album_ поле singer снабжено аннотацией *_@ManyToOne_*, где задается другая сторона связи с классом Singer. В этом коде была также указана аннотация *_@JoinColumn_* для столбца с именем внешнего ключа.

==== Связи "many-to-many"

Каждый певец может играть на нескольких музыкальных инструментах или ни на одном из них, а каждый инструмент может быть связан с несколькими певцами или же ни с одним из них, что, по существу, означает связь "*_many-to-many_*". Для таких связей требуется промежуточная таблица, через которую осуществляется соединение. В данном случае это таблица singer_instrument:

*_See_* _p490_start_with_hibernate/entity/Singer.java_

Для реализации такой связи над полем _instruments_ класса _Singer_ требуются две аннотации:

1. *_@ManyToMany(cascade = {CascadeType.PERSIST, CascadeType.MERGE,CascadeType.DETACH})_* для указания many-to-many связи и настройке каскадности (при действиях над *_id_* entity Singer). ВАЖНО! Нельзя использовать *_CascadeType.DELETE_* и *_CascadeType.ALL_* (т.к. включает в себя все типы каскадности, в т.ч. и DELETE) над _@ManyToMany_, иначе при удалении певца вы удалите и все связанные с ним инструменты. Подробнее см по link:https://thorben-janssen.com/avoid-cascadetype-delete-many-assocations/[ссылке].
2. Совместно с ней используется аннотация *_@JoinTable_* для указания промежуточной таблицы для соединения, которую должна искать библиотека Hibernate.
- Атрибут *_name_* задает имя промежуточной таблицы.
- В атрибуте *_joinColumns_* определяется столбец внешнего ключа для текущей entity (Singer), а в атрибуте *_inverseJoinColumns_* указывается столбец с внешним ключом для таблицы Instrument на другой стороне устанавливаемой связи.

*_See_* _p490_start_with_hibernate/entity/Instrument.java_

В класса Instrument дополнительно реализована другая сторона рассматриваемого здесь отношения (значения аттрибутов joinColumns и inverseJoinColumns поменялись местами).

=== CascadeTypes

Есть несколько типов каскадных операций (*_See_* link:https://www.baeldung.com/jpa-cascade-types[jpa-cascade-types], link:https://sysout.ru/tipy-cascade-primer-na-hibernate-i-spring-boot/[rus tutorial]):

- CascadeType.PERSIST - при добавлении парента добавляются чайлды.
- CascadeType.MERGE - при обновлении парента обновляются чайлды.
- CascadeType.REMOVE - при удалении самого парента удаляются чайлды.
- CascadeType.REFRESH - при перезагрузки парента из базы перезагружаются чайлды.
- CascadeType.DETACH - при убирании парента из EntityManager убираются и чайлды.
