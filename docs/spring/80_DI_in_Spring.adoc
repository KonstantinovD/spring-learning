== Внедрение зависимостей в Spring

(also see https://www.baeldung.com/spring-dependency-injection)

По существу, инверсия управления, а следовательно, и внедрение зависимостей направлены на то, чтобы предоставить простой механизм для снабжения компонента зависимостями (часто называемыми взаимодействующими объектами) и управления ими на протяжении всего их жизненного цикла. Компонент, которому требуются определенные зависимости, зачастую называется зависимым объектом, а в случае инверсии управления - целевым объектом.

Вообще говоря, инверсия управления может быть разделена на два подтипа: *внедрение зависимостей* и *поиск зависимостей*. Эти подтипы подразделяются далее на конкретные реализации служб инверсии управления. Из этого определения ясно видно, что когда речь идет о внедрении зависимостей, всегда имеется в виду инверсия управления. Но когда речь идет об инверсии управления, то не всегда имеется в виду внедрение зависимостей. Например, __**поиск зависимостей**__ - это также форма инверсии управления. +
Если инверсия управления реализуется как поиск зависимостей, то компонент должен получить ссылку на зависимость, тогда как при внедрении зависимостей последние внедряются в компонент контейнером инверсии управления.

У поиска зависимостей имеются две разновидности:

- извлечение зависимостей
- контекстный поиск зависимостей (CDL)

У внедрения зависимостей тоже имеются две разновидности:

- через конструктор
- через метод установки.

===== Извлечение зависимостей:

Этот тиn инверсии уnравления nреобладает в nриложениях на платформе *_JEE_*, где применяется каркас *_EJB_* вплоть до версии 2.1 и широко употребляются операции поиска в службе *_JNDI_* для получения зависимостей из реестра.

[source, java]
----
import org.springfrarnework.context.ApplicationContext;
import org.springfrarnework.context.support
.ClassPathXmlApplicationContext;

public class DependencyPull {
    public static void main( String... args) {
        ApplicationContext ctx =
            new ClassPathXmlApplicationContext("spring/app-context.xml" );
        MessageRenderer mr = ctx.getBean("renderer", MessageRenderer.class);
        mr.render();
    }
}
----

===== Контекстный поиск зависимостей

контекстный nоиск зависимостей (CDL) nодобен извлечению зависимостей, но в этом случае поиск осуществляется в контейнере, управляющем ресурсом, а не только в каком-то центральном реестре. Как правило, контекстный поиск зависимостей производится в установленной точке. +
Механизм контекстного поиска приводится в действие через реализацию в компоненте интерфейса (e. g):

[source, java]
----
public interface ManagedComponent {
    void performLookup(Container container);
}
----
Реализуя этот интерфейс, комnонент извещает *_Container_*, что ему требуется получить зависимость. *_Container_* обычно предоставляется базовым сервером приложений (например, Tomcat или JBoss) или каркасом (в частности, Spring). Как только контейнер будет готов передать зависимости компоненту, он вызовет
метод _performLookup()_ по очереди для каждого компонента.

[source, java]
----
public class ContextualizedDependencyLookup implements ManagedComponent {
    private Dependency dependency;

    @Override
    public void performLookup(Container container) {
        this.dependency = (Dependency) container.getDependency("myDependency");
    }

    @Override
    public String toString() {
        return dependency.toString();
    }
}
----

===== Внедрение зависимостей через конструктор

Происходит в том случае, когда зависимости предоставляются компоненту в его конструкторе (или нескольких конструкторах). Контейнер инверсии управления передает зависимости компоненту при получении его экземпляра. Очевидно, что вследствие внедрения зависимостей через конструктор объект не может быть создан без зависимостей, а следовательно, они обязательны.

===== Внедрение зависимостей через метод установки

Контейнер инверсии управления внедряет зависимости компонента через методы установки в стиле компонентов JavaBeans. Методы установки компонента отражают зависимости, которыми может управлять контейнер инверсии управления. Очевидно, что вследствие внедрения зависимостей через метод установки объект может быть создан без зависимостей, которые могут быть предоставлены в дальнейшем через вызов метода установки.

[source, java]
----
public class SetterInjection {
    private Dependency dependency;

    public void setDependency(Dependency dependency) {
        this.dependency = dependency;
    }
    @Override
    public String toString () {
        return dependency.toString();
    }
}
----

==== Выбор между внедрением зависимостей через конструктор и методом установки

Внедрение зависимостей через конструктор особенно удобно в том случае, если экземпляр класса зависимости должен существовать перед применением компонента. Многие контейнеры, включая и Spring, предоставляют механизм, позволяющий убедиться, все ли зависимости определены, когда они внедряются через метод установки. Но если зависимости внедряются через конструктор, то их требование задается независимо от контейнера.

Внедрение через метод также позволяет решить проблемы с Circular Dependency: https://www.baeldung.com/circular-dependencies-in-spring
