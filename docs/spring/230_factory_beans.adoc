=== Применение фабрик компонентов Spring Beans

Пользуясь каркасом Spring, вы непременно столкнетесь с трудностями реализации и внедрения зависимостей, которые нельзя просто создать с помощью операции _new_. Для этого в Spring предоставляется интерфейс *_FactoryBean_*, действующий в качестве адаптера для тех объектов, которые нельзя создавать и манипулировать ими с помощью стандартной семантики Spring (через new). К их числу относятся Beans, доступные через *_статические фабричные методы_*. Интерфейс FactoryBean и реализующий его Bean выполняет функции фабрики для других компонентов Spring Beans.

Такие фабрики конфигурируются в контексте типа ApplicationContext подобно обычным компонентам Spring Beans, но когда интерфейс FactoryBean применяется в Spring для удовлетворения запроса на внедрение или поиск зависимости, вместо возврата экземпляра компонента, реализующего интерфейс FactoryBean, вызывается метод *_FactoryBean.getObject()_* и возвращается результат этого вызова.

Фабрики бинов применяются в Spring для решения важных задач, наиболее примечательными из которых является 1) *_создание объектов-заместителей для транзакций_* (глава 9), а также *_автоматическое извлечение ресурсов из контекста JNDI_*. Но фабрики компонентов Spring Beans полезны не только для реализации внутренних функций Spring. Они очень удобны и для построения собственных приложений, поскольку позволяют *_манипулировать с помощью инверсии управления намного большим количеством ресурсов_*, чем доступно обычно.

==== Класс МessageDigestFactoryBean как пример фабрики компонентов Spriпg Веапs

Зачастую в разрабатываемых проектах требуется определенная разновидность *_криптографической обработки_*. Как правило, это связано с формированием свертки сообщения или хешированием пользовательского пароля для его сохранения в базе данных. В языке Java имеется класс *_MessageDigest_*, предоставляющий функциональные средства для формирования свертки сообщения из произвольных данных. Сам класс *_MessageDigest_* является абстрактным, а его конкретные реализации получаются через вызов метода *_MessageDigest.getInstance()_*, которому передается _наименование применяемого алгоритма свертки_. Так, если для формирования свертки сообщения требуется применить алгоритм MDS, то получить экземпляр класса MessageDigest можно следующим образом:

[source, java]
----
MessageDigest md5 = MessageDigest.getinstance("MDS");
----

Если каркас Spring должен управлять процессом создания объекта типа *_MessageDigest_*, то самое лучшее, что можно сделать без интерфейса *_FactoryBean_*, - предусмотреть в бине свойство (например, _algorithmName_) и затем сделать *_обратный вызов при инициализации_*, чтобы обратиться к методу *_MessageDigest.getInstance()_*. Однако, эту логику можно инкапсулировать в самом бине с помощью интерфейса _FactoryBean_. И тогда в любых других бинах, где требуется экземпляр класса *_MessageDigest_*, достаточно _объявить свойство_ (например, _messageDigest_) и получить нужный экземпляр с помощью интерфейса FactoryBean. Пример реализации интерфейса FactoryBean для выполнения этих функций: +
**__See__** _p230_factory_beans/MessageDigestFactoryBean.java_, _p230_factory_beans/..._
