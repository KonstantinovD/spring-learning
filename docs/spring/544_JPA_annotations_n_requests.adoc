=== JPA аннотации и запросы

==== JPA аннотации

Код, написанный ранее для _Hibernate_, ксодержит совместимые с JPA аннотации пакета _javax.persistence_, а это означает, что они уже совместимы с _JPA_.

Как только компонент типа _EntityManagerFactory_ будет сконфигурирован надлежащим образом, внедрить его в свои классы не составит большого труда. Ниже приведен исходный код класса SingerServiceimpl, который послужит в качестве примера для выполнения операций в базе данных через прикладной интерфейс JPA.

*_See_* _p538_JPA_configuration_n_structure/service/SingerServiceImpl.java_

В _SingerServiceImpl.java_ применяется несколько аннотаций:

- *_@Service_* - по сути, ничем не отличается от *_@Component_*. Разве что им маркируют сервисы.
- Аннотация *_@Repository_* указывает на то, что в данном классе содержится логика доступа к данным, а каркасу Spring предписывается _преобразовывать_ характерные для поставщика услуг _исключения_ в иерархию исключений типа *_DataAccessException_*, определенную в Spring.

Для внедрения интерфейса *_EntityManager_* служит аннотация *_@PersistenceContext_*, которая является стандартной аннотацией JPA для внедрения диспетчера сущностей. На вопрос, почему выбрано такое имя, можно ответить, что сам контекст сохраняемости (persistence) находится под управлением интерфейса *_EntityManager_*. Если в приложении присутствует немало единиц сохраняемости, в аннотацию можно также ввести атрибут *_unitName_*, чтобы указать внедряемую единицу сохраняемости. Обычно единица сохраняемости представляет отдельный источник данных типа DataSource в СУРБД.

==== Запрашивание данных на языке JPQL

*_See_* _p538_JPA_configuration_n_structure/service/SingerServiceImpl.java_

В методе _SingerServiceImpl.findAll()_ вызывается метод *_EntityManager.createNamedQuery()_*, которому передается имя запроса и ожидаемый тип возвращаемого результата. В данном случае _диспетчер сущностей_ типа *_EntityManager_* возвратит реализацию интерфейса _TypedQuery<X>_. Затем вызывается метод _TypedQuery.getResultList()_ для извлечения сведений о певцах. +

А метод _SingerServiceImpl.listSingersWithAlbumAndInstrument()_ будет выбирать все связанные альбомы и музыкальные инструменты. В нем используется другой именованный запрос с активизированным предложением *_left join fetch_*.

Также представлена возможность найти Singer по его id в методе _SingerServiceImpl.findById()_

Пример работы с этими методами можно увидеть в: +
*_See_* _SpringJPADemo.call_listAll(...)_, _SpringJPADemo.call_listSingersWAnI(...)_, _SingerServiceImpl.call_findById(...)_

==== Вставка данных

Вставка данных средствами JPA осуществляется очень просто. Как и в библиотеке Hibernate, в прикладном интерфейсе JPA поддерживается извлечение первичного ключа, генерируемого базой данных.

*_See_* _SingerServiceImpl.findById()_, _QueryHelper.insert()_

Если id = null, значит, это новый экземпляр сущности и будет вызван метод *_EntityManager.persist()_*. При вызове _persist()_ _диспетчер сущностей_ *_EntityManager_* сохраняет сущность и делает ее управляемым экземпляром в контексте сохраняемости. +
Если же значение id существует, значит, выполняется обновление и будет вызван метод *_EntityManager.merge()_*.

ВАЖНО! (*_See_* _QueryHelper.insert()_) После добавления зависимого объекта в список главного (*_one-to-many_*), надо *_установить главный объект в соответствующее поле зависимого объекта_*. В противном случае зависимый объект (_Album_) не сможет сохраниться и упадет с *_"singer_id is null"_*. Пример такого кода представлен ниже:

[source, java]
----
singer.getAlbums().add(album1);
album1.setSinger(singer);
----

==== Обновление данных

Допустим, для певца необходимо обновить имя и удалить альбом. _Удаление альбома возможно потому_, что в связи *_@OneToMany_* определен атрибут *_orphanRemoval=true_*, предписывающий поставщику услуг JPA (Hibernate) удалить все висячие записи, существующие в базе данных, но больше не обнаруживаемые в объекте при сохранении.

==== Обновление данных

Удаление альбома через удаление из сета фиг настроишь. Зато можно вызвать "clear()" и зачистить все. +
А имя уже изменяется.

*_See_* _SingerServiceImpl.findById()_, _QueryHelper.update(...)_

==== Удаление данных

Прежде всего, необходимо вызвать метод *_EntityManager.merge()_* для объединения состояния сущности с текущим контекстом сохраняемости. Затем вызывается метод *_EntityManager.remove()_*, которому передается смерженный экземпляр. Метод _remove()_ удаляет запись о певце, а также все связанные с ним сведения, включая альбомы и музыкальные инструменты, поскольку в преобразовании было задано условие cascade=CascadeType. ALL.

*_See_* _SingerServiceImpl.delete()_, _QueryHelper.delete(...)_
