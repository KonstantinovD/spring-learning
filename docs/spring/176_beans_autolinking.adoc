=== Автосвязывание компонентов Spring Beans

==== Автосвязывание без @Autowired

Автосвязывание не требует аннотаций. Пример автосвязывания без аннотаций можно видеть в: +
*_See_* _p176_beans_autolinking/withoutAutowired/..._ +
Здесь используется автосвязывание по типу (*_Plane.seat_*) и по имени (*_Plane.superjetCockpit_*).

==== Режимы автосвязывания

В Spring поддерживается пять режимов автосвязывания:

- Режим *_no_*. Выбирается по умолчанию.
- Режим *_default_*. Spring автоматически выбирает между режимами *_constructor_* и *_ЬуТуре_*. Если у компонента Spring Bean имеется *_конструктор по умолчанию_* (т.е. без аргументов), то выбирается режим автосвязывания _ЬуТуре_, иначе - режим _constructor_.
- Режим *_byName_*. Spring пытается связать каждое свойство с одноименным компонентом Spring Bean. Так, если у целевого Bean имеется поле *_fоо_* и в контексте типа ApplicationContext определен компонент *_foo_*, то этот компонент присваивается свойству *_foo_* целевого Bean.
- Режим *_bуТуре_*. Spring пытается связать каждое свойство целевого компонента Spring Bean с компонентом *_того же самого типа_*, автоматически выбираемым из ApplicationContext.
- Режим *_constructor_*. Этот режим действует подобно режиму ЬуТуре, за исключением того, что *_зависимости внедряются в нем через конструкторы_*, а не методы установки. Каркас Spring пытается *_обнаружить совпадение с как можно большим числом аргументов в конструкторе_*. Но это только в XML! При использовании аннотаций - можно ревлизовать ровно 1 конструктор. +
*_See_* _p176_beans_autolinking/ConstructorsTarget.java_, _p176_beans_autolinking/TrickyTarget.java_

Если Spring обнаружил бины, но не в состоянии выбрать из них тот, который требуется применить, то мы получаем *_UnsatisfiedDependencyException_* (Caused by *_NoUniqueBeanDefinitionException_*). В этом случае поможет аннотация @Primary. *_See_* _p176_beans_autolinking/TrickyTarget.java_
