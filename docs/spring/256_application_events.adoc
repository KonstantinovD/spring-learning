=== События в приложениях

Еще одной _особенностью_ интерфейса *_ApplicationContext_*, отсутствующей в интерфейсе _BeanFactory_, является возможность *_публиковать и получать события_*, используя интерфейс _ApplicationContext_ в качестве посредника.

1. *_Событие_*. Создаваемый класс события наследуется абстрактного *_ApplicationEvent_*, который, в свою очередь, наследуется от класса *_java.util.EventObject_*.
2. *_Приемник_*. Любой бин может *_принимать события_*, реализовав интерфейс *_ApplicationListener<T>_*, и тогда в контексте _ApplicationContext_ этот бин автоматически регистрируется в качестве приемника событий.
3. *_Публикатор_*. События публикуются с помощью метода *_ApplicationEventPublisher.publishEvent()_*, поэтому публикующий их класс должен быть осведомлен об интерфейсе _ApplicationContext_, расширяющем интерфейс *_ApplicationEventPublisher_*. +
В *_веб-приложении_* это достигается просто, поскольку многие классы являются производными от классов из каркаса Spring, которые обеспечивают доступ к _ApplicationContext_ через защищенный метод. +
А для того чтобы публиковать события в *_автономном_* приложении, Bean должен реализовать интерфейс *_ApplicationContextAware_*.

*_See_* _p256_application_events/..._

==== Когда применять события

Как правило, в приложении *_требуется уведомлять_* определенные *_компоненты_* о тех или иных *_событиях_*. И зачастую для этого пишется код, явно уведомляющий каждый компонент, или же применяется какая-нибудь технология обмена сообщениями вроде *_JMS_*. Недостаток первого варианта заключается в том, что компоненты привязываются к публикующему классу, что зачастую нежелательно.

Рассмотрим ситуацию, когда: +
1. Подробные сведения о товаре кешируются в приложении, чтобы избежать лишних обращений к базе данных; +
2. В другом компоненте разрешается видоизменить подробные сведения о товаре и сохранить их в базе данных. +
Чтобы данные в кеше не оказались недействительными, компонент обновления явно уведомляет кеш о том, что сведения о товаре изменились. Компонент обновления публикует событие всякий раз, когда подробные сведения о товаре изменяются, а заинтересованные компоненты, в том числе и компонент кеша, принимают это событие. Преимущество такого решения заключается в том, что компоненты остаются несвязанными, а это упрощает внедрение другого приемника событий, заинтересованного в получении сведений об изменении подробных сведений о товаре.

Применение технологии _JMS_ (не говоря уже о *_Kafka_*) в данном случае было бы излишним, поскольку процесс объявления недействительной записи о товаре в кеше оказывается быстрым и некритичным. А применение инфраструктуры Spring для обработки событий влечет за собой весьма незначительные издержки в приложении. Как правило, события применяются для реализации такой логики реагирования, которая действует быстро и не является частью основной логики приложения.
