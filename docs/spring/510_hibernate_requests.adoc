=== Выборка данных на языке запросов Hibernate

- Запрос с выборкой связей
- Вставка и обновление данных
- Удаление данных
- Соображения по поводу применения Hibernate

==== Запрос с выборкой связей

*_See_* _p490_start_with_hibernate/..._

Извлечь данные из связей (_many-to-one_ и др.) средствами Hibernate можно одним из трех способов.

1. Связь можно определить с режимом выборки *_EAGER_*: *_@ManyToMany(fetch=FetchType.EAGER)_*. Тем самым предписывается выбирать связанные записи по каждому запросу. Но такой способ оказывает отрицательное влияние на производительность при извлечении данных.
2. Второй способ - выбирать связанные данные только по требованию в запросе. Так, если делается запрос типа *_Criteria_*, можно вызвать метод *_Criteria.setFetchMode()_*, чтобы Hibernate произвела выборку связи.
3. А если делается запрос типа *_NamedQuery_*, то можно воспользоваться операцией *_fetch_*, чтобы предписать библиотеке Hibernate немедленно произвести выборку связи. _NamedQuery_ запрос может быть вынесен в ХМL-файл или объявлен с помощью аннотации в классе сущности. Рассмотрим в качестве примера реализации методов _findAllWithAlbum()_ и _findAllWithAlbumAndInstrument()_:

*_See_* _p490_start_with_hibernate/entity/Singer.java_, _p490_start_with_hibernate/dao/impl/SingerDaoImpl.java_

==== Вставка и обновление данных

Вставка/обновление данных в Hibernate осуществляется очень просто. Единственная особенность состоит в извлечении первичного ключа, сгенерированного базой данных. Hibernate извлечет сгенерированный ключ и заполнит объект предметной области после вставки. Пример реализации метода save() для класса Singer:

[source, java]
----
public Singer save(Singer singer) {
    sessionFactory.getCurrentSession().saveOrUpdate(singer);
    log.info("Singer saved with id: "+ singer.getld());
    return singer;
}
----

В данном случае достаточно вызвать метод *_Session.saveOrUpdate()_*,который может использоваться для выполнения операций *_вставки_* и *_обновления_*. Кроме того, здесь протоколируется идентификатор сохраненного обьекта, который представляет певца и будет заполнен средствами Hibernate после сохранения в базе данных.

==== Удаление данных

Удаление данных выполняется также просто. Для этого достаточно вызвать метод *_Session.delete()_*, передав ему удаляемый объект.

==== Соображения по поводу применения Hibernate

Hibernate может обеспечить среду, которая позволит сосредоточить основное внимание на программировании с помощью объектной модели, а не на построении операторов SQL для каждой операции. В последние годы библиотека Hibernate быстро развивалась и была принята широким сообществом разработчиков приложений на Java. Однако не следует забывать об отсутствии всякого контроля над генерируемыми операторами SQL - необходимо очень тщательно определять преобразования, особенно связи и связанную с ними стратегию выборки информации из базы данных. Кроме того, необходимо внимательно следить за операторами SQL, которые генерирует библиотека Hibernate, чтобы удостовериться в их правильном поведении.

Понимание внутреннего механизма управления сеансами Hibernate также играет очень важную роль, особенно в *_пакетных операциях_*. Библиотека Hibernate _хранит управляемые объекты в своем сеансе, регулярно сбрасывая и очищая их_. Неудачно спроектированная логика доступа к данным может привести к тому, что библиотека Hibernate будет очищать свой сеанс слишком часто, из-за чего значительно снизится производительность. Если же требуется полный контроль над запросом, можно воспользоваться собственным запросом (*_@Query_*).

Важную роль в настройке производительности Hibernate играют также параметры, в том числе размер пакета, объем выборки и т.д. Эти параметры следует определить в фабрике сеансов и корректировать на стадии нагрузочного тестирования разрабатываемого приложения с целью обнаружить их оптимальные значения.