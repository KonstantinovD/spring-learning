== JAVA — QUESTIONS

- Типы данных, переменные, операторы, циклы, массивы
- Java — ООП

=== Типы данных, переменные, операторы, циклы, массивы
*_See_* link:https://javastudy.ru/interview/basics-types-operators-arrays/[link]

- 24. Что вы знаете о классах оболочках? +
  25.Что такое автоупаковка (link:https://habr.com/ru/post/329498/[boxing/unboxing])? +


=== Java — ООП
*_See_* link:https://javastudy.ru/interview/java-oop/[link1], link:https://javastudy.ru/interview/java-oop2/[link2], link:https://javastudy.ru/interview/java-oop3/[link3]

- 0. Композиция и агрегирование. Ассоциация. (Композиция - потребляемый объект не может существовать в отрыве от зависимого, агрегация - может существовать и до, и после жизненного цикла зависимого объекта. Ассоциация - тупо ссылка, композиция и агрегация - ее подвиды)
- 1. Назовите принципы ООП и расскажите о каждом.
- 6. Чем отличаются конструкторы по умолчанию, копирования и конструктор с параметрами? (про _clone()_)
- 8. Расскажите об особенностях класса с единственным private конструктором. (Нельзя наследоваться)
- 10. Дайте определение понятию “метод”. (Метод — это последовательность команд, которые вызываются по определенному имени. Можно сказать что это функция и процедура (в случае void метода))
- 13. Могут ли нестатические методы перегрузить статические?
(Да. Это будут просто два разных метода для программы)
- 14. Могут ли быть переопределены статические методы? (Нет, переопределить базовый статический метод нельзя)
- 25. Можно ли объявить метод абстрактным и статическим одновременно?
(Нет. Модификатор abstract говорит, что метод будет реализован в другом классе, а static указывает, что этот метод будет доступен по имени класса)
- 26. Что означает ключевое слово static? (Метод или поле класса принадлежат не объекту, а классу. Т.е. доступ можно будет получить и не создавая объекта класса. Поля помеченные static инициализируются при инициализации класса.)
- 30. Что такое статический класс, какие особенности его использования? (*_See_* _ch2_plain_java/sn7_static_nested_classes_q26_oop/..._)
- 37. Какие типы классов бывают в java? (Обычные классы (_Top level classes_), Interfaces, Enums, _Static nested classes_, _Member inner classes_, _Local/Anonymous inner classes_)
- 49. В чем особенность работы методов hashCode и equals? (*_public int hashCode()_*)
- 51. Что будет, если переопределить equals не переопределяя hashCode? Какие могут возникнуть проблемы? (Если *_hashCode()_* не переопределен, то реализация по умолчанию в классе Object дает разные значения для разных объектов, даже если они равны согласно методу _equals()_. Так для объекта HashMap это может привести к тому, что пара, которая была помещена в Map возможно не будет найдена в ней при обращении к Map, если используется новый экземпляр ключа(положили пару key-value, потом создали новый объект key, у которого другой hashcode, непереопределенный - место в памяти - и теперь мы не можем найти value по этому новому key).)
- 54. Чем отличается абстрактный класс от интерфейса, в каких случаях что вы будете использовать?
1. Абстрактный класс может реализовывать методы; интерфейс может реализовывать *_статические_* методы начиная с 8й версии.
2. Интерфейс может _описывать_ *_константы_* и методы. Все методы интерфейса по умолчанию являются публичными (public) и абстрактными (abstract), а поля — _public static final_. С java 8 в интерфейсах можно реализовывать default и статические методы.
- 55. Можно ли получить доступ к private переменным класса и если да, то каким образом? (*_See_* _ch2_plain_java/sn8_reflection/..._)
- 58. Имеет ли смысл объявлять метод private final? (Нет, такой метод и так не виден для наследников, а значит не может быть ими переопределен.)
- 60. К конструктору не применимо ключевое слово *_final_*.

=== Exceptions

*_See_* link:https://javastudy.ru/interview/exceptions/[link] и link:https://habr.com/ru/company/golovachcourses/blog/225585/[habr]

- 8. Могли бы вы придумать ситуацию, когда блок finally не будет выполнен?
[source, java]
----

try {
    System.exit(0);
} catch(Exception e) {
    e.printStackTrace();
} finally { }
----
- 15. Может ли метод main выбросить исключение во вне и если да, то где будет происходить обработка данного исключения? (Может, и оно будет передано в JVM)
- 16. Если оператор return содержится и в блоке catch и в finally, какой из них “главнее”? (Вернется из блока finally)
- 18. SQLException - checked (По версии Joshua Bloch, это попытка заставить разработчиков обработать исключение и обернуть его в новом уровне абстракции)

=== Collections
*_See_* link:https://javastudy.ru/interview/collections/[link1]

- 14. _NavigableSet_/_Map_ - это интерфейсы
- 15. Что вы знаете о реализации классов HashSet и TreeSet? (Они содержат внутри себя мапу, хранение *_null_* в TreeSet недопустимо, в HashSet допустимо)
- 16. HashMap loadFactor? (link:https://www.javatpoint.com/load-factor-in-hashmap#:~:text=The%20Load%20factor%20is%20a,%25%20of%20the%20map%20size[link])
- 23. _Collections.synchronizedList(list)_ vs _concurrent.CopyOnWriteArrayList_ (link:https://javarevisited.blogspot.com/2016/05/what-is-difference-between-synchronized.html#:~:text=The%20main%20reason%20for%20this,sophisticated%20techniques%20like%20lock%20stripping[link])
- 25. Как получить коллекцию только для чтения? (_Collections.unmodifiableList(list)_, etc)
- 31. В чем разница между Iterator и ListIterator? (_ListIterator_ может добавлять значения в список с помощью *_add()_*. ListIterator позволяет перебирать список в обоих направлениях - метод *_previous()_*)
- 33. В чем разница между fail-safe и fail-fast свойствами? (Итераторы fail-safe не вызывают никаких исключений при изменении структуры коллекции, потому что они работают с клоном коллекции вместо оригинала. Пример:
итератор коллекции _CopyOnWriteArrayList_)
- 36. В чем разница между интерфейсами _Comparable_ и _Comparator_? (Интерфейс Comparable помогает сохранять естественную сортировку, тогда как Comparator позволяет сортировать элементы по разным особым шаблонам)
- 37. Реализация сортировки в Java? (link:https://ru.stackoverflow.com/questions/33385/%D0%A1%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0-%D0%B2-java[link], _Arrays.sort(*<primitive[]>*)_ - quick sort (неустойчивая, но разницы между равными примитивами нет); _Arrays.sort(*<Object[]>*)_, _Collections.sort()_ - merge sort (устойчивая))

=== Работа со String
*_See_* link:https://javastudy.ru/interview/strings/[link]

- 3. Можно ли наследовать строковый тип, почему? (Нет, String - final class)
- 7. Как перевернуть строку? (_stringBuilder.reverse()_)
- 8. Как работает сравнение двух строк? (equals() -> посимвольно)
- 12. Дайте определение понятию “пул строк”. (Для выражения *_String s = "Hi"_* сначала ищется строка в пуле с таким же значением.
Для оператора new создается новый объект строки, а затем мы можем использовать метод intern() для того, чтобы поместить строку в пул, или получить из пула ссылку на другой объект String с таким же значением.)
- 18. Можно ли синхронизировать доступ к строке? (String сам по себе потокобезопасный класс. Если мы работаем с изменяемыми строками, то нужно использовать StringBuffer.)
- 19. Что делает метод intern()?
- 22. Почему строка неизменная и финализированная в Java?
- 23. Почему массив символов предпочтительнее строки для хранения пароля? (Строка хранится в пуле строк некоторое время, пока не будет удалена GC, и кто-либо, имеющий доступ к дампу памяти сможет найти пароль в виде чистого текста.
Если мы используем массив символов для хранения пароля, мы можем очистить его после того, как закончим с ним работать)
- 24. Почему строка является популярным ключом в HashMap в Java? (Поскольку строки неизменны, их хэшкод кэшируется в момент создания, и не требует повторного пересчета. Это делает строки отличным кандидатом для ключа в Map и они обрабатываются быстрее, чем другие объекты-ключи HashMap.)

=== Потоки ввода/вывода

*_See_* link:https://javastudy.ru/interview/input-output/[link] +
Also see link:http://developer.alexanderklimov.ru/android/java/io.php[link2]

- 1. Какие существуют виды потоков ввода/вывода? (Байтовые - InputStream/OutputStream и символьные - Writter/Reader)
- 3. Что общего и чем отличаются следующие потоки: InputStream, OutputStream, Reader, Writer?
- 4. Что вы знаете о RandomAccessFile? (Наследуется напрямую от Object и не наследуется от базовых классов ввода\вывода. Предназначен для работы с файлами, поддерживая произвольный доступ к их содержимому)
- 5. Какие есть режимы доступа к файлу? (RandomAccessFile может открываться в режиме чтения («r») или чтения/записи («rw»). Также есть режим «rws», когда файл открывается для операций чтения-записи и каждое изменение данных файла немедленно записывается на физическое устройство. link:https://devcolibri.com/%D1%83%D1%80%D0%BE%D0%BA-4-randomaccessfile-%D0%B8-%D0%B5%D0%B3%D0%BE-%D0%B2%D0%BE%D0%B7%D0%BC%D0%BE%D0%B6%D0%BD%D0%BE%D1%81%D1%82%D0%B8/[example])
- 7. Что вы знаете о классах-надстройках? (Классы-надстройки наделяют существующий поток дополнительными свойствами. Примеры классов: _BufferedOutputStream_, _BufferedInputStream_, _BufferedWriter_ — буферизируют поток и повышают производительность.)
- 10. Какие классы позволяют преобразовать байтовые потоки в символьные и обратно? (OutputStreamWriter — из Writer в OutputStream; InputStreamReader- из InputStream в Reader)
- 15. Что такое сериализация? (Сериализация это процесс сохранения состояния объекта в последовательность байт)
1. Еще один важный момент: *_private static final long serialVersionUID_*. Это поле содержит уникальный идентификатор версии сериализованного класса. Он есть у любого Serializable-класса и вычисляется по содержимому класса — полям, порядку объявления, методам. И если мы поменяем в нашем классе тип поля и/или количество полей, идентификатор версии моментально изменится. +
_serialVersionUID_ тоже записывается при сериализации класса. Когда мы пытаемся провести десериализацию, то есть восстановить объект из набора байт, значение serialVersionUID сравнивается со значением serialVersionUID класса в нашей программе. Если значения не совпадают, будет выброшено исключение java.io.InvalidClassException. Чтобы избежать таких ситуаций, мы просто вручную задаем _serialVersionUID_.

=== Multithreading
link:https://javastudy.ru/interview/concurrent/[link]

- 1. Дайте определение понятию “процесс”
1. Это *_совокупность кода и данных_*, разделяющих общее виртуальное адресное пространство. Процессы _изолированы_ друг от друга, поэтому прямой доступ к памяти чужого процесса невозможен (взаимодействие между процессами осуществляется с помощью специальных средств).
2. Для каждого процесса ОС создает так называемое _«виртуальное адресное пространство»_, к которому процесс имеет прямой доступ. Оно содержит данные, которые принадлежат только процессу.
- 13. Как принудительно остановить поток? (Напрямую этого сделать нельзя. Класс Thread содержит в себе скрытое булево поле, которое называется флагом прерывания. Установить этот флаг можно вызвав метод interrupt() потока. У методов, приостанавливающих выполнение потока, таких как sleep(), wait() и join() есть одна особенность — если во время их выполнения будет вызван метод interrupt() этого потока, они, не дожидаясь конца времени ожидания, сгенерируют исключение InterruptedException.)
- 19. В каких состояниях может пребывать поток? (NEW, RUNNABLE, BLOCKED, TERMINATED, WAITING, TIMED_WAITING).)
- 20. Что является монитором при вызове нестатического и статического метода? (Для нестатического метода — текущий объект this. Для статического метода — объекта типа Class, соответствующий классу, в котором определен этот метод.)
- 26. Каковы условия вызова метода wait/notify? (Методы должны вызываться на объекте-мониторе только из синхронизированного кода. Поток, который вызывает эти методы должен владеть монитором, иначе будет выдано исключение java.lang.IllegalMonitorStateException.)
- 30. Модификаторы volatile и метод yield()
1. Статический метод _Thread.yield()_ заставляет процессор переключиться на обработку других потоков системы. Метод может быть полезным, например, когда поток ожидает наступления какого-либо события и необходимо чтобы проверка его наступления происходила как можно чаще. В этом случае можно поместить проверку события и метод Thread.yield() в цикл:
[source, java]
----
//Ожидание поступления сообщения
while(!msgQueue.hasMessages()) { //Пока в очереди нет сообщений
	Thread.yield();	//Передать управление другим потокам
}
----
- UncaughtExceptionHandler:
[source, java]
----
public class LastChanceHandler implements Thread.UncaughtExceptionHandler {
    @Override
    public void uncaughtException(Thread t, Throwable e) {
        // do something here - log to file and upload to server / close resources/delete files...
    }
}
----
- 27. ForkJoinPool vs ExecutorService:
1. Fork-join allows you to easily execute divide and conquer jobs, which have to be implemented manually if you want to execute it in ExecutorService. (также см link:https://itsobes.ru/JavaSobes/chto-takoe-forkjoinpool/[itsobes])
2. In practice ExecutorService is usually used to process many independent requests (aka transaction) concurrently, and fork-join when you want to accelerate one coherent job.
3. ForkJoinPool – специальный вид ExecutorService, который предназначен для выполнения рекурсивных задач. Задача для сервиса представляется экземпляром класса ForkJoinTask. В основном используются подклассы _RecursiveTask_ и _RecursiveAction_, для задач с результатом и без соответственно. Аналогично интерфейсам Callable и Runnable обычного ExecutorService. +
Тело рекурсивной операции задается в реализации метода *_compute()_* задачи ForkJoinTask. Здесь же создаются новые подзадачи, и запускаются параллельно методом *_fork()_*. Чтобы дождаться завершения выполнения задачи, на каждой форкнутой подзадаче вызывается блокирующий метод *_join()_*, результат выполнения при необходимости агрегируется. +
С точки зрения использования метод ForkJoinTask.join() похож на аналогичный метод класса Thread. Но в случае fork-join поток может на самом деле не заснуть, а переключиться на выполнение другой задачи. Такая стратегия называется work stealing, и позволяет эффективнее использовать ограниченное количество потоков.
Пример ForkJoinPool с рекурсивными тасками: +
*_See_* _important_links/sn1_fork_join_pool/..._
- 28. Чем CompletableFuture отличается от Future? +
Смотри по ссылке link:https://itsobes.ru/JavaSobes/chem-completablefuture-otlichaetsia-ot-future/[itsobes] +
Future – интерфейс, который представляет пока еще недовычисленный результат. Когда породившая его асинхронная операция заканчивается, он заполняется значением. Метод get блокирует выполнение до получения результата, isDone проверяет его наличие. К примеру результат выполнения задач в ExecutorService, ForkJoinTask, реализует интерфейс Future. +
CompletableFuture появился в Java 8. Это класс-реализация старого интерфейса Future, а значит всё сказанное выше справедливо и для него. Вдобавок к этому, CompletableFuture реализует работу с отложенными результатами посредством коллбэков. Метод thenApply регистрирует код обработки значения, который будет автоматически вызван позже, когда это значение появится.
